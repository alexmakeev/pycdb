var selectionX = [];var selectionY = [];var chosenCid;var chosenRel;var chosenSource;var dragline;Array.max = function( array ){    return Math.max.apply( Math, array );};Array.min = function( array ){    return Math.min.apply( Math, array );};function refreshGraph(){    var type;    var lines = container        .selectAll("polyline")        .data(graph_data[1]);    lines.enter()        .append("polyline")        /*.attr("style",function(d){            type = graph_configuration_data[1].filter(function(r){return r.id === d.cid})[0]            return "stroke:"+ type.color+";stroke-width:"+ type.size;        })        .attr("class", function(d) { return type.shape; })*/        .attr("marker-end", function(d) { return "url(#endmarker)"; })        .attr("cursor","pointer")        .on("click",function(d){            selected_relation = d;        })    lines.attr("style",function(d){        type = graph_configuration_data[1].filter(function(r){return r.id === d.cid})[0]        if(d.selected==2)            return "stroke:lightgrey;stroke-width:1";        else            return "stroke:"+ type.color+";stroke-width:"+ type.size+";fill:none";        })        .attr("class", function(d) {            type = graph_configuration_data[1].filter(function(r){return r.id === d.cid})[0];            return type.shape;        })        .attr("points",function(d){            var source = graph_data[0].filter(function (e) { return (e.cid==d.source[0] && e.id==d.source[1]);})[0]            var target = graph_data[0].filter(function (e) { return (e.cid==d.target[0] && e.id==d.target[1]);})[0]            if(source==target){                var sourceX=source.x+source.size;                var sourceY=source.y+source.size;                return sourceX+","+sourceY+" "+sourceX+","+(sourceY+10)+" "+(sourceX-source.size*2)+","+(sourceY+10)+" "+(sourceX-source.size*2)+","+sourceY;            }            var deltaX = target.x - source.x,                deltaY = target.y - source.y,                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),                normX = deltaX / dist,                normY = deltaY / dist,                sourcePadding = source.size,                targetPadding = parseInt(target.size,10) + 3,                sourceX = source.x + (sourcePadding * normX),                sourceY = source.y + (sourcePadding * normY),                targetX = target.x - (targetPadding * normX),                targetY = target.y - (targetPadding * normY);            return sourceX+","+ sourceY+" "+targetX+","+targetY;        })    lines.exit().remove()    var nodes = container.selectAll("use").data(graph_data[0])    nodes.enter()        .append("use")        .attr("cursor","pointer")        .on("click",function(d){            if(d.selected==2)                return null;            else{                if((chosenRel!=undefined)&&(chosenSource!=undefined)){                    addNewRel(chosenRel.id,chosenSource,d);                    chosenSource=undefined;                    chosenRel=undefined;                    dragline=undefined;                    deleteSelection();                }                else if(chosenRel!=undefined){                    d3.event.stopPropagation();                    chosenSource = d;                    var cids = [];                    chosenRel.allowed_relations.forEach(function(rel){                        var cid = rel.to.cid;                        if((cids.indexOf(cid)==-1)&&(rel.from.cid==d.cid)){                            cids.push(cid);                        }                    })                    selectTypeNodes(cids);                    dragline = container.append("polyline")                        .attr("marker-end", "url(#endmarker)")                        .attr("style",function(){                            return "stroke:"+ chosenRel.color+";stroke-width:"+ chosenRel.size;                        })                        .attr("class", function() {                            return chosenRel.shape;                        })                }                else{                    selectObject(d.cid, d.id);                }            }        })        .call(drag)    nodes.attr("class",function(d){            if(d.selected==2)                return "grey";            else                return null;        })        .attr("x", function(d) {return d.x;})        .attr("y", function(d) {return d.y;})        .attr("xlink:href",function(d){            if(d.shape=="default")                return "#"+graph_configuration_data[0].filter(function (e) { return e.id === d.cid;})[0].shape;            return "#"+ d.shape        })        .attr("fill",function(d){            if(d.color=="default")                return graph_configuration_data[0].filter(function (e) { return e.id === d.cid;})[0].color;            return d.color;        })    nodes.exit().remove()    var texts = container.selectAll("text")       .data(graph_data[0])    texts.enter()       .append("text")       .attr("font-family", "sans-serif")       .attr("font-size", "12px")       .attr("fill", "black");    texts.attr("class",function(d){            if(d.selected==2)                return "grey";            else                return null;        })        .attr("x", function(d) {return d.x;})        .attr("y", function(d) {return d.y;})        .text(function(d) {            return d.title;        })    texts.exit().remove();}function findAllNeighbors(cid,id){    selectionX=[];    selectionY=[];    makeAllNeighbors(cid,id,$("#neighbor_number").val(),0,changeNeighbor);    var sx = (Array.max(selectionX)-Array.min(selectionX))/2;    var sy = (Array.max(selectionY)-Array.min(selectionY))/2;    var area = Array.max([sx,sy])+10;    sx += Array.min(selectionX);    sy += Array.min(selectionY);    graySelected();    refreshGraph();    zoomToArea(sx,sy,area);}function graySelected(){    graph_data[0].forEach(function(d){        if(d.selected != 1) d.selected = 2;    });    graph_data[1].forEach(function(d){        if(d.selected != 1) d.selected = 2;    });}function makeAllNeighbors(cid,id,depth,curdepth,doit){    doit(cid,id);    if(curdepth==depth) return;    graph_data[1].forEach(function(d){        if (d.source[0]==cid&& d.source[1]==id){            d.selected=1;            makeAllNeighbors(d.target[0], d.target[1],depth,curdepth+1,doit);        }        else if(d.target[0]==cid&& d.target[1]==id){            d.selected = 1;            makeAllNeighbors(d.source[0], d.source[1],depth,curdepth+1,doit);        }    });}function changeNeighbor(cid,id){    var node = graph_data[0].filter(function(d){        return d.cid==cid && d.id==id;    })[0];    node.selected = 1;    selectionX.push(node.x);    selectionY.push(node.y);}function zoomToArea(cx,cy,areasize){    scale = 275/(areasize);    x = -(cx - areasize);    y = -(cy - areasize);    container.transition()        .duration(750)        .attr("transform", "scale("+scale+") translate("+x+","+y+")");    zoom.translate([x*scale,y*scale]);    zoom.scale([scale]);}function findNeighbors(){    if(selected_object)    findAllNeighbors(selected_object.cid,selected_object.id);}function deleteSelection(){    graph_data[0].forEach(function(d){        d.selected = 0;    });    graph_data[1].forEach(function(d){        d.selected = 0;    });    refreshGraph();}function addNode(cid,id,x,y){    var new_node = new Object();    new_node.cid = cid;    new_node.id = id;    new_node.x = x;    new_node.y = y;    new_node.color = "default";    new_node.description= "";    new_node.selected = 0;    new_node.shape = "default";    new_node.size= 10;    new_node.title= "";    graph_data[0].push(new_node);    refreshGraph();}function selectTypeNodes(cids){    graph_data[0].forEach(function(d){        if(cids.indexOf(d.cid)!=-1)            d.selected = 1;        else            d.selected = 2;    });    graph_data[1].forEach(function(d){        d.selected = 2;    });    if(chosenSource!=undefined&&chosenRel.id==10001){        chosenSource.selected=2;    }    refreshGraph();}function addRelation(rid,sourceCid,sourceId,targetCid,targetId){    var new_rel = new Object();    new_rel.cid = rid;    new_rel.source = [sourceCid,sourceId];    new_rel.target = [targetCid,targetId];    graph_data[1].push(new_rel);    refreshGraph();}function saveNode(){    if(selected_object==undefined)        return;    if(!$("input[name='color_default']").checked){        selected_object.color=$("input[name='color']").val();    }    selected_object.size=$("input[name='size']").val();    selected_object.shape=$("input[name='shape']").val();    selected_object.title=$("input[name='name']").val();    saveTheNode(selected_object);    refreshGraph();}function colorDefaultClicked(){    if($("input[name='color_default']").is(":checked")){        $("input[name='color']")[0].value=($.grep(graph_configuration_data[0], function(e){ return (e.id == selected_object.cid); })[0].color);    }}function deleteNode(object){    index = graph_data[0].indexOf(object);    graph_data[0].splice(index,1);    refreshGraph();}