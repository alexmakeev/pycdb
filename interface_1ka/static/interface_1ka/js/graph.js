function Graph(canvas){    var self = this;    this.ismouseover = false;    this.zoom = d3.behavior.zoom()        .scaleExtent([1, 20])        .on("zoom", zoomed);    this.drag = d3.behavior.drag()        .origin(function(d) { return d; })        .on("dragstart", dragstarted)        .on("drag", dragged)        .on("dragend", dragended);    this.rectdrag = d3.behavior.drag()        .on("dragstart",rectdragstarted)        .on("drag",rectdragged)        .on("dragend",rectdragended);    this.svg = canvas        .append("g")        .call(this.zoom);    this.svg.append("rect")        .attr("width", "100%")        .attr("height", "100%")        .style("fill", "none")        .style("pointer-events", "all");    this.container = this.svg.append("g");    this.svg.on("mouseup",function(){            if(self.chosenCid){                self.addNode(self.chosenCid);            }        })        .on("mousemove",function(){            //Let's save coordinates of mouse to use it while paste            var p = d3.mouse( self.container.node());            self.mouseX = p[0];            self.mouseY = p[1];            if((self.dragline!=undefined)&&(self.chosenSource!=undefined)){                self.dragline.attr("points",function(d){                    return self.chosenSource.x+","+ self.chosenSource.y+" "+(self.mouseX-3)+","+(self.mouseY-3);                });            }            var s = self.container.select( "rect.selection");            if( self.sel_start!=undefined) {                d3.event.stopPropagation();                var d = {};                d.x = (self.sel_start.x>p[0])?p[0]:self.sel_start.x;                d.y = (self.sel_start.y>p[1])?p[1]:self.sel_start.y;                d.width = Math.abs(self.sel_start.x-p[0]);                d.height = Math.abs(self.sel_start.y-p[1]);                s.attr( d);            }        })        .on("mousedown",function(){            if($("#selection_button").hasClass("pressed")){                self.container.selectAll( "rect.selection").remove();                var p = d3.mouse( self.container.node());                self.addSelectionRectangle(p[0],p[1],0,0);                self.sel_start = {                    x: p[0],                    y: p[1]                }            }        })        .on("mouseover",function()        {            self.ismouseover = true;        })        .on("mouseout",function()        {            self.ismouseover = false;        });    //Get key down events for copy functionality    $(document).keydown(function(e) {        self.closeSelection();        if(e.ctrlKey|| e.metaKey)        {            if (e.keyCode==67)            {                self.saveSelection();            }            else if(e.keyCode==88)            {                self.saveSelection();                self.removeSelectedObjects();            }            else if(e.keyCode==86)            {                //Check if mouse is over canvas                if(self.ismouseover)                {                    self.pasteSelection(self.mouseX,self.mouseY);                }                //testJson = d3.select(self.container.node()).attr("transform");                //testJson = self.container.node().getBoundingClientRect();                //alert(d3.mouse(self.container.node()));                //alert(d3.select(self.container.node()).attr("transform"));            }        }    });    d3.select("body").on("mouseup",function(){            self.chosenCid = undefined;            self.sel_start = undefined;            self.closeSelection();        })        .on("click",function(){            if((self.dragline!=undefined)){                self.chosenRel=undefined;                self.chosenSource=undefined;                self.dragline=undefined;                self.deleteSelection();            }        });    $("#selection_button").on("click",function(){        if($("#selection_button").hasClass("pressed"))            $("#selection_button").removeClass("pressed");        else            $("#selection_button").addClass("pressed");    })};Graph.prototype.setData = function(data){    this.graph_data = data;    this.refreshGraph();    //testJson = this.graph_data;};Graph.prototype.setChosenCid = function(cid){    this.chosenCid = cid;};Graph.prototype.setChosenRel = function(relation){    var cids = [];    if(relation==undefined||relation.allowed_relations==undefined)        return;    relation.allowed_relations.forEach(function(rel){        var cid = rel.from.cid;        if(cids.indexOf(cid)==-1){            cids.push(cid);        }    })    this.chosenRel = relation;    this.selectTypeNodes(cids);};Graph.prototype.setConfigData = function(data){    this.graph_configuration_data = data;};Graph.prototype.selectTypeNodes = function(cids){    if(this.graph_data==undefined||this.graph_data[0]==undefined||this.graph_data[1]==undefined||this.chosenRel==undefined)        return;    this.graph_data[0].forEach(function(d){        if(cids.indexOf(d.cid)!=-1)            d.selected = 1;        else            d.selected = 2;    });    this.graph_data[1].forEach(function(d){        d.selected = 2;    });    if(this.chosenSource!=undefined&&this.chosenRel.id==10001){        this.chosenSource.selected=2;    }    this.refreshGraph();};Graph.prototype.addNode = function(cid,id){    if(!this.chosenCid) return;    var coords = d3.mouse(this.container.node());    if(this.graph_data==undefined)        return;    var new_node = new Object();    new_node.cid = this.chosenCid;    new_node.id = id;    new_node.x = coords[0];    new_node.y = coords[1];    new_node.color = "default";    new_node.description= "";    new_node.selected = 0;    new_node.shape = "default";    new_node.size= 10;    new_node.title= "";    $(document).trigger("add_new_node",[new_node]);};Graph.prototype.addNodeOnGraph = function(new_node){    this.graph_data[0].push(new_node);    this.refreshGraph();}Graph.prototype.addRel = function(target){    var new_rel = new Object();    new_rel.cid = this.chosenRel.id;    new_rel.source = [this.chosenSource.cid,this.chosenSource.id];    new_rel.target = [target.cid,target.id];    $(document).trigger("add_new_rel",[new_rel]);}//adds relation on our viewGraph.prototype.addRelOnGraph = function(new_rel){    this.graph_data[1].push(new_rel);    this.refreshGraph();}//removes highlight mask from selected objectsGraph.prototype.deleteSelection = function(){    if(this.graph_data==undefined||this.graph_data[0]==undefined||this.graph_data[1]==undefined)        return;    this.graph_data[0].forEach(function(d){        d.selected = 0;    });    this.graph_data[1].forEach(function(d){        d.selected = 0;    });    this.refreshGraph();};Graph.prototype.selectObject = function(cid,id){    //this.deleteSelection();    var selected_object = $.grep(this.graph_data[0], function(e){ return (e.id == id && e.cid==cid); })[0];    $(document).trigger("object_selected",selected_object);}Graph.prototype.deleteNode = function(object){    var index = this.graph_data[0].indexOf(object);    var relations_to_del = [];    this.graph_data[0].splice(index,1);    this.graph_data[1].forEach(function(rel){        if((rel.source[0]===object.cid&&rel.source[1]===object.id)||(rel.target[0]===object.cid&&rel.target[1]===object.id)){            relations_to_del.push(rel);        }    });    for(var i=0;i<relations_to_del.length;i++){        index = this.graph_data[1].indexOf(relations_to_del[i]);        this.graph_data[1].splice(index,1);    }    this.refreshGraph();}Graph.prototype.deleteRelation = function(object){    var index = this.graph_data[1].indexOf(object);    this.graph_data[1].splice(index,1);    this.refreshGraph();}Graph.prototype.findAllNeighbors = function(cid,id,number){    this.selectionX=[];    this.selectionY=[];    this.makeAllNeighbors(cid,id,number,0);    var sx = (Array.max(this.selectionX)-Array.min(this.selectionX))/2;    var sy = (Array.max(this.selectionY)-Array.min(this.selectionY))/2;    var area = Array.max([sx,sy])+10;    sx += Array.min(this.selectionX);    sy += Array.min(this.selectionY);    this.graySelected();    this.refreshGraph();    this.zoomToArea(sx,sy,area);}Graph.prototype.makeAllNeighbors = function(cid,id,depth,curdepth){    var d;    var self = this;    var node = this.graph_data[0].filter(function(d){        return d.cid==cid && d.id==id;    })[0];    node.selected = 1;    this.selectionX.push(node.x);    this.selectionY.push(node.y);    if(curdepth==depth) return;    this.graph_data[1].forEach(function(d){        if (d.source[0]==cid&& d.source[1]==id){            d.selected=1;            self.makeAllNeighbors(d.target[0], d.target[1],depth,curdepth+1);        }        else if(d.target[0]==cid&& d.target[1]==id){            d.selected = 1;            self.makeAllNeighbors(d.source[0], d.source[1],depth,curdepth+1);        }    });}Graph.prototype.graySelected = function(){    this.graph_data[0].forEach(function(d){        if(d.selected != 1) d.selected = 2;    });    this.graph_data[1].forEach(function(d){        if(d.selected != 1) d.selected = 2;    });}Graph.prototype.closeSelection = function(){    if($("#selection_button").hasClass("pressed")){        var d = d3.select("rect.selection");        this.graph_data[0].forEach(function(node){            if(                (node.selected!=2)&&                (node.x-node.size/2>=parseInt(d.attr("x"))) && (node.x+node.size/2<=parseInt(d.attr("x"))+parseInt(d.attr("width"))) &&                (node.y-node.size/2>=parseInt(d.attr("y"))) && (node.y+node.size/2<=parseInt(d.attr("y"))+parseInt(d.attr("height")))            ) {                node.inselection = true;            }else{                node.inselection = false;            }        });    }}Graph.prototype.moveSelection = function(){    var p = d3.mouse(this.container.node());    if(this.lastmove!=undefined){        var shift = {            x: p[0]-this.lastmove[0],            y: p[1]-this.lastmove[1]        }        var rect = this.container.selectAll("rect.selection");        rect.attr("x",parseInt(rect.attr("x"))+shift.x);        rect.attr("y",parseInt(rect.attr("y"))+shift.y);        this.graph_data[0].forEach(function(node){            if(node.inselection){                node.x+=shift.x;                node.y+=shift.y;            }        })        this.refreshGraph();    }    this.lastmove = p;}Graph.prototype.endMoveSelection = function(){    this.lastmove = undefined;}Graph.prototype.saveSelection = function(){    this.selection = [[],[]];    selection = this.selection;    if (d3.select("rect.selection")[0].length == 0)        return;    //We want to save rectangle of selection too to paste it at future    var rect_selection = this.container.select("rect.selection");    this.selection.push({        x: parseFloat(rect_selection.attr("x")),        y: parseFloat(rect_selection.attr("y")),        width: parseInt(rect_selection.attr("width")),        height: parseInt(rect_selection.attr("height"))});    for(var i=0;i<this.graph_data[0].length;i++){        var node=this.graph_data[0][i];        if(node.inselection){            this.selection[0].push(jQuery.extend(true, {}, node));        }    }    for(var j=0;j<this.graph_data[1].length;j++){        var edge=this.graph_data[1][j];        var isSourceInlist = false;        var isTargetInlist = false;        for(var i=0;i<this.graph_data[0].length;i++){            var node=this.graph_data[0][i];            if(node.inselection){                if((node.cid==edge.source[0] && node.id==edge.source[1]))                {                    isSourceInlist = true;                }                if((node.cid==edge.target[0] && node.id==edge.target[1]))                {                    isTargetInlist = true;                }            }        };        if(isSourceInlist&&isTargetInlist)            this.selection[1].push(jQuery.extend(true, {}, edge));    };    this.changeSelectionCoordinates(0,0);}//removes selected objectsGraph.prototype.removeSelectedObjects = function(){    this.graph_data[0].forEach(function(node)    {        if(node.inselection)        {            $(document).trigger("delete_node",node);        }    })}//Sets coordinates for all parts of selectionGraph.prototype.changeSelectionCoordinates = function(x,y){    var rect_selection = this.selection[2];    //differences between needed coordinates and selection rectangle coordinates    var difX = rect_selection["x"]-x;    var difY = rect_selection["y"]-y;    rect_selection.x -= difX;    rect_selection.y -= difY;    this.selection[0].forEach(function(node)    {        node.x -= difX;        node.y -= difY;    })}//Removes all existion selectionsGraph.prototype.removeSelections = function(){    this.container.selectAll( "rect.selection").remove();    this.graph_data[0].forEach(function(node)    {        node.inselection = false;    })}//Paste selection on mapGraph.prototype.pasteSelection = function(x,y){    if ((this.selection == undefined)||(this.selection[2]==undefined))        return;    //Remove all selections    this.removeSelections();    //Change saved selection coordinates to push    this.changeSelectionCoordinates(x,y);    //paste selection rectangle    var rect_selection = this.selection[2];    this.addSelectionRectangle(rect_selection.x,rect_selection.y,rect_selection.width,rect_selection.height);    //paste nodes and edges    if(this.selection[0].length==0) return;    $(document).trigger("add_fragment",{nodes: this.selection[0],rels:this.selection[1]});}//Add fragment in graphGraph.prototype.addFragmentOnGraph = function(fragment){    var i;    for(i=0;i<fragment.nodes.length;i++)    {        this.addNodeOnGraph(fragment.nodes[i]);    }    for(i=0;i<fragment.rels.length;i++)    {        this.addRelOnGraph(fragment.rels[i]);    }}Graph.prototype.refreshGraph = function(){    var type;    var self = this;    var config_data = this.graph_configuration_data;    var graph_data = this.graph_data;    var lines = this.container        .selectAll("polyline")        .data(this.graph_data[1]);    lines.enter()        .append("polyline")        .attr("marker-end", function(d) { return "url(#endmarker)"; })        .attr("cursor","pointer")        .on("click",function(d){            $(document).trigger("relation_selected",d);        })    lines.attr("style",function(d){        type = config_data[1].filter(function(r){return r.id === d.cid})[0];        if(d.selected==2)            return "stroke:lightgrey;stroke-width:1";        else            return "stroke:"+ type.color+";fill:none;stroke-width:"+ type.size+";fill:none";        })        .attr("class", function(d) {            type = config_data[1].filter(function(r){return r.id === d.cid})[0];            return type.shape;        })        .attr("points",function(d){            var source = graph_data[0].filter(function (e) { return (e.cid==d.source[0] && e.id==d.source[1]);})[0]            var target = graph_data[0].filter(function (e) { return (e.cid==d.target[0] && e.id==d.target[1]);})[0]            if(source==target){                var sourceX=source.x+source.size/2;                var sourceY=source.y+source.size/2;                var height = 5;                return sourceX+","+(sourceY-3)+" "+sourceX+","+(sourceY+height)+" "+(sourceX-source.size)+","+(sourceY+height)+" "+(sourceX-source.size)+","+sourceY;            }            var deltaX = target.x - source.x,                deltaY = target.y - source.y,                dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),                normX = deltaX / dist,                normY = deltaY / dist,                sourcePadding = source.size/2,                targetPadding = parseInt(target.size/2,10) + 5,                sourceX = source.x + (sourcePadding * normX),                sourceY = source.y + (sourcePadding * normY),                targetX = target.x - (targetPadding * normX),                targetY = target.y - (targetPadding * normY);            return sourceX+","+ sourceY+" "+targetX+","+targetY;        })    lines.exit().remove()    var nodes = this.container.selectAll("path").data(this.graph_data[0])    nodes.enter()        .append("path")        .attr("cursor","pointer")        .on("click",function(d){            if(d.selected==2)                return null;            else{                if((self.chosenRel!=undefined)&&(self.chosenSource!=undefined)){                    //d3.event.stopPropagation();                    self.addRel(d);                    self.chosenSource=undefined;                    self.chosenRel=undefined;                    self.dragline=undefined;                    self.deleteSelection();                }                else if(self.chosenRel!=undefined){                    d3.event.stopPropagation();                    self.chosenSource = d;                    var cids = [];                    if(self.chosenRel.allowed_relations!=undefined){                        self.chosenRel.allowed_relations.forEach(function(rel){                            var cid = rel.to.cid;                            if((cids.indexOf(cid)==-1)&&(rel.from.cid==d.cid)){                                cids.push(cid);                            }                        })                        self.selectTypeNodes(cids);                        self.dragline = self.container.append("polyline")                            .attr("marker-end", "url(#endmarker)")                            .attr("style",function(){                                return "stroke:"+ self.chosenRel.color+";stroke-width:"+ self.chosenRel.size;                            })                            .attr("class", function() {                                return self.chosenRel.shape;                            })                    }                }                else{                    $(document).trigger("object_selected",d);                }            }        })        .call(this.drag)    nodes.attr("class",function(d){            if(d.selected==2)                return "grey";            else                return null;        })        /*.attr("x", function(d) {return d.x- d.size/2;})        .attr("y", function(d) {return d.y- d.size/2;})*/        .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })        .attr("d", d3.svg.symbol()        .size(function(d) { return d.size*20; })        .type(function(d) {            if(d.shape=="default")                return config_data[0].filter(function (e) { return e.id === d.cid;})[0].shape;            return d.shape;        }))        /*.attr("xlink:href",function(d){            if(d.shape=="default")                return "#"+config_data[0].filter(function (e) { return e.id === d.cid;})[0].shape;            return "#"+ d.shape        })*/        .attr("fill",function(d){            if(d.color=="default")                return config_data[0].filter(function (e) { return e.id === d.cid;})[0].color;            return d.color;        })    nodes.exit().remove()    var texts = this.container.selectAll("text")       .data(this.graph_data[0])    texts.enter()       .append("text")       .attr("font-family", "sans-serif")       .attr("font-size", "12px")       .attr("fill", "black");    texts.attr("class",function(d){            if(d.selected==2)                return "grey";            else                return null;        })        .attr("x", function(d) {return d.x;})        .attr("y", function(d) {return d.y;})        .text(function(d) {            return d.title;        })    texts.exit().remove();};//Add selection rect on mapGraph.prototype.addSelectionRectangle = function(x,y,width,height){    this.container.append( "rect")        .attr({            rx      : 6,            ry      : 6,            class   : "selection",            x       : x,            y       : y,            width   : width,            height  : height        }).call(this.rectdrag);}Graph.prototype.zoomTransform = function(translate,scale){    this.container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");}var zoomed = function() {    $(document).trigger("zoom_transform");//this.container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");};Graph.prototype.zoomToArea = function(cx,cy,areasize){    scale = 275/(areasize);    x = -(cx - areasize);    y = -(cy - areasize);    this.container.transition()        .duration(750)        .attr("transform", "scale("+scale+") translate("+x+","+y+")");    this.zoom.translate([x*scale,y*scale]);    this.zoom.scale([scale]);};Graph.prototype.zoomTo = function(cid,id){    d = $.grep(this.graph_data[0], function(e){ return (e.id == id && e.cid==cid); })[0]    area = d.size+7;    this.zoomToArea(d.x, d.y,area);};var dragstarted = function(d) {    d3.event.sourceEvent.stopPropagation();    d3.select(this).classed("dragging", true);};var dragged = function(d) {    d3.select(this).attr("x", d.x = d3.event.x).attr("y", d.y = d3.event.y);    $(document).trigger("refresh_graph");};var dragended = function(d) {    d3.select(this).classed("dragging", false);    $(document).trigger("save_coords");};var rectdragstarted = function(d) {    d3.event.sourceEvent.stopPropagation();    d3.select(this).classed("dragging", true);    $(document).trigger("move_selection");    //testJson = this;};var rectdragged = function() {    //d3.select(this).attr("x", d3.event.x).attr("y", d3.event.y);    $(document).trigger("move_selection");};var rectdragended = function(d) {    d3.select(this).classed("dragging", false);    $(document).trigger("end_move_selection");};Array.max = function( array ){    return Math.max.apply( Math, array );};Array.min = function( array ){    return Math.min.apply( Math, array );};function getAbsoluteXY(element) {   var viewportElement = document.documentElement;   var box = element.getBoundingClientRect();   var scrollLeft = viewportElement.scrollLeft;   var scrollTop = viewportElement.scrollTop;   var x = box.left + scrollLeft;   var y = box.top + scrollTop;   return {"x": x, "y": y}}