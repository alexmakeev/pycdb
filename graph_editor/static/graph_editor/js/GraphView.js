/** * Created by 1ka on 4/5/14. */ZOOMPYCDB.namespace("ZOOMPYCDB.GraphView");ZOOMPYCDB.GraphView = function (model, elements) {    var model = model,        canvas = elements.canvas,        body = elements.body,        ismouseover = false,        mouse_coord = {"x": 0, "y": 0},        scale,        zoom,        drag,        dragback,        rectdrag,        svg,        container,        dragline,        dragline_coord,        selection_rect,        sel_start,        last_mouse_pos,        lines_path,        nodes_path,        background_image,        zscale,        cc,        svg_group,    //refreshes canvas        refresh = function () {            var type,                config_data = model.getConfigData(),                graph_data = model.getGraph(scale),                lines, nodes, texts, background;            //ZOOMPYCDB.test = graph_data;            if ((config_data === undefined) || (graph_data === undefined))                return;            background_img = background_image.selectAll("image").data(graph_data.bgs.filter(function (d) {                return d.image.match(/\.(jpeg|jpg|gif|png)$/);            }).sort(function (a, b) {                return (a.z > b.z) ? 1 : -1;            }));            background_img.enter()                .call(function (d) {                    this.append("image")                        .call(dragback)                        .on("click", function (d) {                            $(document).trigger("bg_clicked", d);                        });                });            background_img                .attr("xlink:href", function (d) {                    return d.image;                })                .attr("transform", function (d) {                    return "translate(" + (d.x - d.width / 2) + "," + (d.y - d.height / 2) + ")";                })                .attr("width", function (d) {                    return d.width;                })                .attr("height", function (d) {                    return d.height;                })                .attr("style", function (d) {                    if (d.chosen)                        return "opacity:1";                    else                        return "opacity:0.5";                });            background_img.exit().remove();            bg_svg = background_image.selectAll("g").data(graph_data.bgs.filter(function (d) {                return d.image.match(/\.(svg)$/);            }).sort(function (a, b) {                return (a.z > b.z) ? 1 : -1;            }));            bg_svg.enter()                .append("g")                .each(function (d, i) {                    var g = d3.select(this);                    d3.xml(d.image, "image/svg+xml", function (error, documentFragment) {                        if (error) {                            $(document).trigger("error_message", error);                            return;                        }                        svgNode = documentFragment.getElementsByTagName("svg")[0];                        result = "translate(" + d.x + "," + d.y + "),scale(" + d.width / svgNode.getAttribute("width") + "," + d.height / svgNode.getAttribute("height") + ")";                        g.node().appendChild(svgNode);                        g.attr("transform", result);                    });                });            bg_svg.exit().remove();            lines = lines_path                .selectAll("path")                .data(graph_data.rels);            lines.enter()                .append("path")                .attr("marker-end", function (d) {                    return "url(#endmarker)";                })                .attr("cursor", "pointer")                .on("click", function (d) {                    $(document).trigger("rel_clicked", d);                });            lines.attr("style", function (d) {                type = config_data.rels.filter(function (r) {                    return r.id === d.cid;                })[0];                if (d.selected == 2)                    return "stroke:lightgrey;stroke-width:1;fill:none";                else                    return "stroke:" + type.color + ";fill:none;stroke-width:" + type.size + ";fill:none";            })                .attr("class", function (d) {                    type = config_data.rels.filter(function (r) {                        return r.id === d.cid;                    })[0];                    return type.shape;                })                .attr("d", function (d) {                    var source = graph_data.nodes.filter(function (e) {                        return (e.cid == d.source[0] && e.id == d.source[1]);                    })[0];                    var target = graph_data.nodes.filter(function (e) {                        return (e.cid == d.target[0] && e.id == d.target[1]);                    })[0];                    if (source == target) {                        var xRotation = 0,                            largeArc = 1,                            drx = target.size * 2 / 3,                            dry = target.size / 3,                            x2 = target.x - target.size / 2 - 2,                            y2 = target.y + target.size / 2,                            x1 = source.x + target.size / 2,                            y1 = source.y + target.size / 2,                            sweep = 1;                        if (d.neighbor_number != undefined) {                            dry = dry + (d.neighbor_number) * 4;                        }                        return "M" + x1 + "," + y1 + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;                    }                    var deltaX = target.x - source.x,                        deltaY = target.y - source.y,                        dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),                        normX = deltaX / dist,                        normY = deltaY / dist,                        sourcePadding = 0,                        targetPadding = parseFloat(target.size / 2, 10) + 5,                        sourceX = source.x + (sourcePadding * normX),                        sourceY = source.y + (sourcePadding * normY),                        targetX = target.x - (targetPadding * normX),                        targetY = target.y - (targetPadding * normY),                        dr = Math.sqrt(deltaX * deltaX + deltaY * deltaY);                    if (d.neighbor_number != undefined)                        dr = dr * d.neighbor_number;                    return "M" +                        sourceX + "," +                        sourceY + "A" +                        dr + "," + dr + " 0 0,1 " +                        targetX + "," +                        targetY;                });            lines.exit().remove();            nodes = nodes_path.selectAll("path").data(graph_data.nodes);            nodes.enter().append("path")                .call(drag)                .attr("cursor", "pointer")                .on("click", function (d) {                    if (d.selected == 2)                        return;                    d3.event.stopPropagation();                    $(document).trigger("node_clicked", d);                });            nodes                .attr("class", function (d) {                    if (d.selected == 2)                        return "grey";                    else if (d.inselection)                        return "inselection";                    else if (d.chosen)                        return "chosen";                    else                        return null;                })                .attr("transform", function (d) {                    return "translate(" + d.x + "," + d.y + ")";                })                .attr("d", d3.svg.symbol()                    .size(function (d) {                        return d.size * d.size;                    })                    .type(function (d) {                        var default_node = config_data.nodes.filter(function (e) {                            return e.id === d.cid;                        })[0];                        if (d.image || (default_node.image && d.shape == "default"))                            return "circle";                        else if (d.shape == "default") {                            return default_node.shape;                        }                        return d.shape;                    }))                .attr("fill", function (d) {                    var default_node = config_data.nodes.filter(function (e) {                        return e.id === d.cid;                    })[0];                    if (d.image || (default_node.image && d.shape == "default"))                        return "white";                    else if (d.color == "default")                        return default_node.color;                    return d.color;                });            /*node.append("image")             .attr("xlink:href",function(d){             return "http://upload.wikimedia.org/wikipedia/commons/2/25/HTML5_Shiny_Icon.svg";             })             .attr("transform", function(d) { return "translate(" + (d.x- d.size/2) + "," + (d.y- d.size/2) + ")"; })             .attr("width",function(d) { return d.size;});             .attr("height",function(d) { return d.size;});*/            nodes.exit().remove();            var nodes_img = nodes_path.selectAll("image").data(graph_data.nodes);            nodes_img.enter().append("image")                .call(drag)                .attr("cursor", "pointer")                .on("click", function (d) {                    if (d.selected == 2)                        return;                    d3.event.stopPropagation();                    $(document).trigger("node_clicked", d);                });            nodes_img.attr("xlink:href", function (d) {                var default_node = config_data.nodes.filter(function (e) {                    return e.id === d.cid;                })[0];                if (d.image)                    return d.image;                else if (default_node.image && d.shape == "default")                    return default_node.image;                else                    return "";            })                .attr("transform", function (d) {                    return "translate(" + (d.x - d.size / 2) + "," + (d.y - d.size / 2) + ")";                })                .attr("width", function (d) {                    return d.size;                })                .attr("height", function (d) {                    return d.size;                })                .attr("class", function (d) {                    if (d.selected == 2)                        return "grey";                    else if (d.inselection)                        return "inselection";                    else if (d.chosen)                        return "chosen";                    else                        return null;                });            nodes_img.exit().remove();            texts = container.selectAll("text")                .data(graph_data.nodes);            texts.enter()                .append("text")                .attr("font-family", "sans-serif")                .attr("font-size", "12px")                .attr("fill", "black");            texts.attr("class", function (d) {                if (d.selected == 2)                    return "grey";                else                    return null;            })                .attr("x", function (d) {                    return d.x + d.size / 2;                })                .attr("y", function (d) {                    return d.y - d.size / 2;                })                .text(function (d) {                    return d.title;                });            texts.exit().remove();            zscale                .text("z=" + Math.round(scale * 100) / 100);        },        clickcancel = function () {            var event = d3.dispatch('click', 'dblclick');            function cc(selection) {                var down,                    tolerance = 5,                    last,                    wait = null;                // euclidean distance                function dist(a, b) {                    return Math.sqrt(Math.pow(a[0] - b[0], 2), Math.pow(a[1] - b[1], 2));                }                selection.on('mouseup', function () {                    down = d3.mouse(document.body);                    last = +new Date();                    if (dist(down, d3.mouse(document.body)) > tolerance) {                        return;                    } else {                        if (wait) {                            window.clearTimeout(wait);                            wait = null;                            event.dblclick(d3.event);                        } else {                            wait = window.setTimeout((function (e) {                                return function () {                                    event.click(e);                                    wait = null;                                };                            })(d3.event), 300);                        }                    }                });            };            return d3.rebind(cc, event, 'on');        },        zoomed = function () {            scale = d3.event.scale;            container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");            refresh();        },        dragstarted = function (d) {            if (d.selected == 2)                return;            d3.event.sourceEvent.stopPropagation();            d3.select(this).classed("dragging", true);        },        dragged = function (d) {            if (d.selected == 2)                return;            d.x = d3.event.x;            d.y = d3.event.y;            $(document).trigger("node_moved", d);        },        dragended = function (d) {            if (d.selected == 2)                return;            d3.select(this).classed("dragging", false);            $(document).trigger("drag_ended", d);        },        rectdragstarted = function () {            d3.event.sourceEvent.stopPropagation();            d3.select(this).classed("dragging", true);            //$(document).trigger("selection_moved");        },        rectdragged = function () {            $(document).trigger("selection_moved");        },        rectdragended = function () {            d3.select(this).classed("dragging", false);            $(document).trigger("end_move_selection");        },        dragbackstarted = function (d) {            if (d.chosen) {                d3.event.sourceEvent.stopPropagation();            }        },        backdraged = function (d) {            if (d.chosen) {                d.x = d3.event.x;                d.y = d3.event.y;                $(document).trigger("bg_moved", d);            }        },        dragbackended = function (d) {            if (d.chosen) {                $(document).trigger("drag_bg_ended", d);            }        };    //zooms to defined area    zoomToArea = function (cx, cy, areasize) {        var scale,            canvasel = canvas[0][0],            canvassize = (canvasel.clientHeight <= canvasel.clientWidth) ? canvasel.clientHeight / 2 : canvasel.clientWidth / 2,            x = -(cx - areasize),            y = -(cy - areasize);        scale = canvassize / (areasize);        container.transition()            .duration(750)            .attr("transform", "scale(" + scale + ") translate(" + x + "," + y + ")");        zoom.translate([x * scale, y * scale]);        zoom.scale([scale]);    },        //stops dragline        closeDragLine = function () {            if (dragline) {                dragline.remove();                //dragline = undefined;            }        },        //adds dragline        addDragLine = function (chosen_rel, coord) {            dragline_coord = coord;            dragline = container.append("polyline")                .attr("marker-end", "url(#endmarker)")                .attr("style", function () {                    return "stroke:" + chosen_rel.color + ";stroke-width:" + chosen_rel.size;                })                .attr("class", function () {                    return chosen_rel.shape;                });        },        //moves dragline        moveDragLine = function () {            if (dragline && dragline_coord) {                dragline.attr("points", function () {                    return dragline_coord.x + "," + dragline_coord.y + " " + (mouse_coord.x - 3) + "," + (mouse_coord.y - 3);                });            }        },        //close selection rectangle        closeSelectionRect = function () {            sel_start = undefined;        },        //add selection rectangle        addSelectionRect = function (x, y, width, height) {            if (x !== undefined && y !== undefined && width !== undefined && height !== undefined) {                selection_rect = container.append("rect")                    .attr({                        rx: 6,                        ry: 6,                        class: "selection",                        x: x,                        y: y,                        width: width,                        height: height                    }).call(rectdrag);            }        },        //start new selection rectangle        startSelectionRect = function () {            addSelectionRect(mouse_coord.x, mouse_coord.y, 0, 0);            sel_start = {                "x": mouse_coord.x,                "y": mouse_coord.y            };        },        //remove any selection rectangles        removeSelectionRect = function () {            container.selectAll("rect.selection").remove();            selection_rect = undefined;        },        //change selection rectangle        changeSelectionRect = function (event) {            if (sel_start) {                event.stopPropagation();                var d = {};                d.x = (sel_start.x > mouse_coord.x) ? mouse_coord.x : sel_start.x;                d.y = (sel_start.y > mouse_coord.y) ? mouse_coord.y : sel_start.y;                d.width = Math.abs(sel_start.x - mouse_coord.x);                d.height = Math.abs(sel_start.y - mouse_coord.y);                selection_rect.attr(d);            }        },        //moves selection        moveSelectionRect = function (shift) {            selection_rect.attr("x", parseFloat(selection_rect.attr("x")) + shift.x);            selection_rect.attr("y", parseFloat(selection_rect.attr("y")) + shift.y);        },        //stops shift counting        endMoveSelectionRect = function () {            last_mouse_pos = undefined;        },        getSelectionRect = function () {            var result = {};            if (selection_rect) {                result.x = parseFloat(selection_rect.attr("x"));                result.y = parseFloat(selection_rect.attr("y"));                result.width = parseFloat(selection_rect.attr("width"));                result.height = parseFloat(selection_rect.attr("height"));            }            return result;        },        //checks if selection rectangle is closed        isSelectionClosed = function () {            if (sel_start) return false;            else return true;        },        //gets mouse container coordinates        getMouseCoord = function () {            var result = (!ismouseover) ? undefined : jQuery.extend(true, {}, mouse_coord);            return result;        },        //sets mouse container coordinates        setMouseCoord = function (coord) {            mouse_coord.x = coord[0];            mouse_coord.y = coord[1];        },        isMouseOver = function () {            return ismouseover;        },        //gets shift between last mouse position and current mouse position        getShift = function () {            var shift = {                x: 0,                y: 0            };            if (last_mouse_pos) {                shift.x = mouse_coord.x - last_mouse_pos.x;                shift.y = mouse_coord.y - last_mouse_pos.y;            }            last_mouse_pos = jQuery.extend(true, {}, mouse_coord);            return shift;        };    zoom = d3.behavior.zoom()        .scaleExtent([0.1, 60])        .on("zoom", zoomed);    drag = d3.behavior.drag()        .origin(function (d) {            return d;        })        .on("dragstart", dragstarted)        .on("drag", dragged)        .on("dragend", dragended);    dragback = d3.behavior.drag()        .origin(function (d) {            return d;        })        .on("dragstart", dragbackstarted)        .on("drag", backdraged)        .on("dragend", dragbackended);    //selection rectangle dragging    rectdrag = d3.behavior.drag()        .on("dragstart", rectdragstarted)        .on("drag", rectdragged)        .on("dragend", rectdragended);    svg = canvas        .append("g")        .call(zoom);    svg.append("rect")        .attr("width", "100%")        .attr("height", "100%")        .style("fill", "none")        .style("pointer-events", "all");    scale = 1;    cc = clickcancel();    container = svg.append("g");    background_image = container.append("g");    lines_path = container.append("g");    nodes_path = container.append("g");    svg.on("mousemove", function () {        var p = d3.mouse(container.node());        setMouseCoord(p);        $(document).trigger("graph_mouse_moved", d3.event);    }).on("mousedown", function () {        $(document).trigger("graph_mouse_down", d3.event);    })        .on("mouseover", function () {            ismouseover = true;        })        .on("mouseout", function () {            ismouseover = false;        })        .call(cc);    cc.on("click", function () {        $(document).trigger("graph_mouse_click");    })        .on("dblclick", function () {            $(document).trigger("graph_mouse_dblclick");        });    $("body").bind("paste", function (event) {        var url = event.originalEvent.clipboardData.getData('text/plain');        if (ismouseover) {            if (url.match(/\.(jpeg|jpg|gif|png|svg)$/) != null) {                $(document).trigger("bg_pasted", [url, scale]);            }            else {                $(document).trigger("selection_pasted");            }        }    });    body.on("mouseup", function () {        $(document).trigger("graph_mouse_up");    });    zscale = svg.append("text")        .attr("x", "490")        .attr("y", "10");    addSelectionRect(0, 0, 0, 0);    $(document).on("graph_changed", function () {        refresh();    });    $(document).on("config_changed", function () {        refresh();    });    $(document).on("bg_selected", function () {    });    $(document).on("zoomed", function (e, sx, sy, area) {        zoomToArea(sx, sy, area);    });    return{        refresh: refresh,        zoomToArea: zoomToArea,        closeDragLine: closeDragLine,        addDragLine: addDragLine,        moveDragLine: moveDragLine,        getMouseCoord: getMouseCoord,        addSelectionRect: addSelectionRect,        startSelectionRect: startSelectionRect,        changeSelectionRect: changeSelectionRect,        removeSelectionRect: removeSelectionRect,        closeSelectionRect: closeSelectionRect,        moveSelectionRect: moveSelectionRect,        endMoveSelectionRect: endMoveSelectionRect,        getSelectionRect: getSelectionRect,        isSelectionClosed: isSelectionClosed,        isMouseOver: isMouseOver,        getShift: getShift    };};